# Raft-Items

### items

+ 日志复制

    领导人来决定什么时候把日志条目应用到状态机中是安全的；这种日志条目被称为已提交。Raft 算法保证所有已提交的日志条目都是持久化的并且最终会被所有可用的状态机执行。在领导人将创建的日志条目复制到大多数的服务器上的时候，日志条目就会被提交

+ 选举限制

    在任何基于领导人的一致性算法中，领导人都必须存储所有已经提交的日志条目。在某些一致性算法中，例如 Viewstamped Replication，某个节点即使是一开始并没有包含所有已经提交的日志条目，它也能被选为领导人。这些算法都包含一些额外的机制来识别丢失的日志条目并把他们传送给新的领导人，要么是在选举阶段要么在之后很快进行。不幸的是，这种方法会导致相当大的额外的机制和复杂性。Raft 使用了一种更加简单的方法，它可以保证在选举的时候新的领导人拥有所有之前任期中已经提交的日志条目，而不需要传送这些日志条目给领导人。这意味着日志条目的传送是单向的，只从领导人传给跟随者，并且领导人从不会覆盖自身本地日志中已经存在的条目。

    Raft 使用投票的方式来阻止一个候选人赢得选举，除非这个候选人包含了所有已经提交的日志条目。候选人为了赢得选举必须联系集群中的大部分节点，这意味着每一个已经提交的日志条目在这些服务器节点中肯定存在于至少一个节点上。如果候选人的日志至少和大多数的服务器节点一样新（这个新的定义会在下面讨论），那么他一定持有了所有已经提交的日志条目。请求投票（RequestVote） RPC 实现了这样的限制：RPC 中包含了候选人的日志信息，然后投票人会拒绝掉那些日志没有自己新的投票请求。

    Raft 通过比较两份日志中最后一条日志条目的索引值和任期号定义谁的日志比较新。如果两份日志最后的条目的任期号不同，那么任期号大的日志更加新。如果两份日志最后的条目任期号相同，那么日志比较长的那个就更加新。

+ 选举超时时间

    - 大于RPC请求时间，防止无用的选举，至少等待3-4次RPC的请求时间
    - 随机时间，用来防止脑裂，但要尽可能的小，使得停机时间短，时间越短就越能开始选举，但又会增加重新选举的概率
    - 

### refs:

+ https://github.com/maemual/raft-zh_cn/blob/master/raft-zh_cn.md

### explain

+ raft的安全性证明就是要考虑各种异常情况下，一致性的保证
+ 异常情况主要包括网络错误（断开，重连）、主机奔溃、恶意篡改等
+ openraft实现了rust共识算法的部分，并开放了相关api供客户实现状态机、日志以及网络组件
+ raft共识算法的核心是暴力的拆分了领导选举和日志复制，并只能通过Leader来做大部分工作，所以他的异常情况可以介绍很多，也更容易理解和实现
+ 为何使用日志，为了重传、顺序性、持久化、试探性提前操作（方便计算空间），考虑追踪系统中使用操作日志快速的记录用户操作行文和kafka顺序写日志实现存储。

### question

+ 如果Leader奔溃，client在raft重新选举完成前如何操作
+ 